# Object.defineProperty()

$\color{green}{1.Object.defineProperty()作用：}$

- Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性。
- 它将返回目标对象。

$\color{green}{2.Object.defineProperty()语法：}$

**$\color{orange}{2.1.语法:}$**
>**Object.defineProperty(obj, prop, descriptor)**

**$\color{orange}{2.2.参数:}$**

- **obj**
    要在其上定义属性的对象。
- **prop**
    要定义或修改的属性的名称。
- **descriptor**
    将被定义或修改的属性描述符。

**$\color{orange}{2.3.返回值:}$**

- 被传递给函数的对象。
  
**$\color{orange}{NOTICED:}$**
**在ES6中，由于 Symbol类型的特殊性，**
**用Symbol类型的值来做对象的key与常规的定义或修改不同，**
**而Object.defineProperty 是定义key为Symbol的属性的方法之一。**

$\color{green}{3.Object.defineProperty()描述：}$

- 该方法允许精确添加或修改对象的属性。
- 通过赋值操作添加的普通属性是可枚举的，能够在属性枚举期间呈现出来（for...in 或 Object.keys 方法）， 这些属性的值可以被改变，也可以被删除。
- 这个方法允许修改默认的额外选项（或配置）。
- 默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的。

$\color{green}{4.Object.defineProperty()属性描述符：}$

**对象里目前存在的属性描述符有两种主要形式：**

- 数据描述符
- 存取描述符
  
**$\color{orange}{4.1.数据描述符：}$**
是一个具有值的属性，该值可能是可写的，也可能不是可写的。

**$\color{orange}{4.2.存取描述符：}$**
是由getter-setter函数对描述的属性。
描述符必须是这两种形式之一。
不能同时是两者。

**$\color{red}{4.3.数据描述符和存取描述符均具有以下可选键值}$(共同拥有的)**
**(默认值是在使用Object.defineProperty()定义属性的情况下)**
$\color{red}{(非在Object.defineProperty()定义属性的情况下，默认值都是true)}$


| 属性         | 特点                                                                                                                                         |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------- |
| configurable | 1.当且仅当该属性的configurable =为 true 时，该属性描述符才能够被改变。<br/>2.同时该属性也能从对应的对象上被删除。<br/>**3.默认值为 false。** |
| enumerable   | 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。<br/>**默认为 false。**                                              |

**$\color{red}{4.4.数据描述符具有以下可选键值：}$(数据描述符特有的)**

| 属性     | 特点                                                                                                   |
| -------- | ------------------------------------------------------------------------------------------------------ |
| value    | 该属性对应的值：<br/>可以是任何有效的 JavaScript 值（数值，对象，函数等）。<br/>**默认为 undefined。** |
| writable | 当且仅当该属性的writable为true时，value才能被赋值运算符改变。<br/>**默认为 false。**                   |

**$\color{red}{4.5.存取描述符具有以下可选键值：}$(存取描述符特有的)**

| 属性 | 特点                                                                                                                                                                                                                             |
| ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| get  | 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。<br/>当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。<br/>**默认为 undefined。** |
| set  | 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。<br/>该方法将接受唯一参数，即该属性新的参数值。<br/>**默认为 undefined。**                                                         |

**$\color{orange}{4.6.属性描述符可同时具有的键值：}$**

|            | configurable | enumerable | value | writable | get | set |
| ---------- | ------------ | ---------- | ----- | -------- | --- | --- |
| 数据描述符 | Yes          | Yes        | Yes   | Yes      | No  | No  |
| 存取描述符 | Yes          | Yes        | No    | No       | Yes | Yes |

**$\color{orange}{NOTICED:}$**

- **如果一个描述符不具有value,writable,get 和 set 任意一个关键字，**
  **那么它将被认为是一个数据描述符。**
- **如果一个描述符同时有(value或writable)和(get或set)关键字，**
  **将会产生一个异常。**

**$\color{orange}{NOTICED:}$**

- **记住，这些选项不一定是自身属性，如果是继承来的也要考虑。**
- **为了确认保留这些默认值，你可能要在这之前冻结 Object.prototype，**
  **明确指定所有的选项，或者通过 Object.create(null)将__proto__属性指向null。**

**Demo**:

```javascript
    // 使用 __proto__
    var obj = {};
    var descriptor = Object.create(null); // 没有继承的属性
    // 默认没有 enumerable，没有 configurable，没有 writable
    descriptor.value = 'static';
    Object.defineProperty(obj, 'key', descriptor);

    // 显式
    Object.defineProperty(obj, "key", {
        enumerable: false,
        configurable: false,
        writable: false,
        value: "static"
    });

    // 循环使用同一对象
    function withValue(value) {
        var d = withValue.d || (
            withValue.d = {
                enumerable: false,
                writable: false,
                configurable: false,
                value: null
            }
        );
        d.value = value;
        return d;
    }
    // ... 并且 ...
    Object.defineProperty(obj, "key", withValue("static"));

    // 如果 freeze 可用, 防止代码添加或删除对象原型的属性
    // （value, get, set, enumerable, writable, configurable）
    (Object.freeze || Object)(Object.prototype);
```

$\color{green}{5.Object.defineProperty() 实例：}$

$\color{orange}{5.1.创建属性：}$

- 如果对象中不存在指定的属性，Object.defineProperty()就创建这个属性。
- 当描述符中省略某些字段时，这些字段将使用它们的默认值。
- 拥有布尔值的字段的默认值都是false。
- value，get和set字段的默认值为undefined。
- 一个没有get/set/value/writable定义的属性被称为“通用的”，并被“键入”为一个数据描述符。

```javascript
        var o = {}; // 创建一个新对象

        // 在对象中添加一个属性与数据描述符的示例
        Object.defineProperty(o, "a", {
            value: 37,
            writable: true,
            enumerable: true,
            configurable: true
        });

        // 对象o拥有了属性a，值为37

        // 在对象中添加一个属性与存取描述符的示例
        var bValue;
        Object.defineProperty(o, "b", {
            get: function () {
                return bValue;
            },
            set: function (newValue) {
                bValue = newValue;
            },
            enumerable: true,
            configurable: true
        });

        o.b = 38;
        // 对象o拥有了属性b，值为38

        // o.b的值现在总是与bValue相同，除非重新定义o.b

        // 数据描述符和存取描述符不能混合使用
        Object.defineProperty(o, "conflict", {
            value: 0x9f91102,
            get: function () {
                return 0xdeadbeef;
            }
        });
        // throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors
```

$\color{orange}{5.2.修改属性：}$

- 如果属性已经存在，Object.defineProperty()将尝试根据描述符中的值以及对象当前的配置来修改这个属性。
- 如果旧描述符将其configurable 属性设置为false，则该属性被认为是“不可配置的”，并且没有属性可以被改变（除了单向改变 writable 为 false）。
- 当属性不可配置时，不能在数据和访问器属性类型之间切换。

**$\color{orange}{注意：}$**
**当试图改变不可配置属性（除了value和writable 属性之外）的值时会抛出TypeError，除非当前值和新值相同。**

**$\color{skyblue}{5.2.1.Writable 属性：}$**
**当writable属性设置为false时，该属性被称为“不可写”。它不能被重新分配。**

```javascript
        var o = {}; // Creates a new object

        Object.defineProperty(o, 'a', {
            value: 37,
            writable: false
        });

        console.log(o.a); // logs 37
        o.a = 25; // No error thrown
        // (it would throw in strict mode,
        // even if the value had been the same)
        console.log(o.a); // logs 37. The assignment didn't work.

        // strict mode
        (function () {
            'use strict';
            var o = {};
            Object.defineProperty(o, 'b', {
                value: 2,
                writable: false
            });
            o.b = 3; // throws TypeError: "b" is read-only
            return o.b; // returns 2 without the line above
        }());
```

如示例所示，试图写入非可写属性不会改变它，也不会引发错误。

**$\color{skyblue}{5.2.2.Enumerable 特性：}$**
**enumerable定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。**

```javascript
        var o = {};
        Object.defineProperty(o, "a", {
            value: 1,
            enumerable: true
        });
        Object.defineProperty(o, "b", {
            value: 2,
            enumerable: false
        });
        Object.defineProperty(o, "c", {
            value: 3
        }); // enumerable defaults to false
        o.d = 4; // 如果使用直接赋值的方式创建对象的属性，则这个属性的enumerable为true

        for (var i in o) {
            console.log(i);
        }
        // 打印 'a' 和 'd' (in undefined order)

        Object.keys(o); // ["a", "d"]

        o.propertyIsEnumerable('a'); // true
        o.propertyIsEnumerable('b'); // false
        o.propertyIsEnumerable('c'); // false
```

**$\color{skyblue}{5.2.3.Configurable 特性：}$**
**configurable特性表示对象的属性是否可以被删除，以及除value和writable特性外的其他特性是否可以被修改。**

```javascript
        var o = {};
        Object.defineProperty(o, "a", {
            get: function () {
                return 1;
            },
            configurable: false
        });

        // throws a TypeError
        Object.defineProperty(o, "a", {
            configurable: true
        });
        // throws a TypeError
        Object.defineProperty(o, "a", {
            enumerable: true
        });
        // throws a TypeError (set was undefined previously)
        Object.defineProperty(o, "a", {
            set: function () {}
        });
        // throws a TypeError (even though the new get does exactly the same thing)
        Object.defineProperty(o, "a", {
            get: function () {
                return 1;
            }
        });
        // throws a TypeError
        Object.defineProperty(o, "a", {
            value: 12
        });

        console.log(o.a); // logs 1
        delete o.a; // Nothing happens
        console.log(o.a); // logs 1
```

如果o.a的configurable属性为true，则不会抛出任何错误，并且该属性将在最后被删除。

$\color{orange}{5.3.添加多个属性和默认值：}$

**考虑特性被赋予的默认特性值非常重要，通常，使用点运算符和Object.defineProperty()为对象的属性赋值时，数据描述符中的属性默认值是不同的，如下例所示。**

```javasscript
        var o = {};

        o.a = 1;
        // 等同于 :
        Object.defineProperty(o, "a", {
            value: 1,
            writable: true,
            configurable: true,
            enumerable: true
        });


        // 另一方面，
        Object.defineProperty(o, "a", {
            value: 1
        });
        // 等同于 :
        Object.defineProperty(o, "a", {
            value: 1,
            writable: false,
            configurable: false,
            enumerable: false
        });
```

$\color{orange}{5.4.一般的 Setters 和 Getters：}$

**下面的例子展示了如何实现一个自存档对象。 当设置temperature 属性时，archive 数组会获取日志条目。**

```javascript
        function Archiver() {
            var temperature = null;
            var archive = [];

            Object.defineProperty(this, 'temperature', {
                get: function () {
                    console.log('get!');
                    return temperature;
                },
                set: function (value) {
                    temperature = value;
                    archive.push({
                        val: temperature
                    });
                }
            });

            this.getArchive = function () {
                return archive;
            };
        }

        var arc = new Archiver();
        arc.temperature; // 'get!'
        arc.temperature = 11;
        arc.temperature = 13;
        arc.getArchive(); // [{ val: 11 }, { val: 13 }]
```

或

```javascript
        var pattern = {
            get: function () {
                return 'I alway return this string,whatever you have assigned';
            },
            set: function () {
                this.myname = 'this is my name string';
            }
        };


        function TestDefineSetAndGet() {
            Object.defineProperty(this, 'myproperty', pattern);
        }


        var instance = new TestDefineSetAndGet();
        instance.myproperty = 'test';

        // 'I alway return this string,whatever you have assigned'
        console.log(instance.myproperty);
        // 'this is my name string'
        console.log(instance.myname);
        继承属性
```

$\color{orange}{5.5.继承属性：}$

- 如果访问者的属性是被继承的，它的 get 和set 方法会在子对象的属性被访问或者修改时被调用。
- 如果这些方法用一个变量存值，该值会被所有对象共享。

```javascript
        function myclass() {}

        var value;
        Object.defineProperty(myclass.prototype, "x", {
            get() {
                return value;
            },
            set(x) {
                value = x;
            }
        });

        var a = new myclass();
        var b = new myclass();
        a.x = 1;
        console.log(b.x); // 1
```

**这可以通过将值存储在另一个属性中解决：**
在 get 和 set 方法中，this 指向某个被访问和修改属性的对象。

```javascript
        function myclass() {}

        Object.defineProperty(myclass.prototype, "x", {
            get() {
                return this.stored_x;
            },
            set(x) {
                this.stored_x = x;
            }
        });

        var a = new myclass();
        var b = new myclass();
        a.x = 1;
        console.log(b.x); // undefined
```

**不像访问者属性，值属性始终在对象自身上设置，而不是一个原型。然而，如果一个不可写的属性被继承，它仍然可以防止修改对象的属性。**

```javascript
        function myclass() {}

        myclass.prototype.x = 1;
        Object.defineProperty(myclass.prototype, "y", {
            writable: false,
            value: 1
        });

        var a = new myclass();
        a.x = 2;
        console.log(a.x); // 2
        console.log(myclass.prototype.x); // 1
        a.y = 2; // Ignored, throws in strict mode
        console.log(a.y); // 1
        console.log(myclass.prototype.y); // 1
```

## $\color{purple}{兼容性问题}$

**数组的 length 属性重定义是可能的，但是会受到一般的重定义限制。（length 属性初始为 non-configurable，non-enumerable 以及 writable。对于一个内容不变的数组，改变其 length 属性的值或者使它变为 non-writable 是可能的。但是改变其可枚举性和可配置性或者当它是 non-writable 时尝试改变它的值或是可写性，这两者都是不允许的。）然而，并不是所有的浏览器都允许 Array.length 的重定义。**

**在 Firefox 4 至 22 版本中尝试去重定义数组的 length 属性都会抛出一个 TypeError 异常。**

**有些版本的Chrome中，Object.defineProperty() 在某些情况下会忽略不同于数组当前length属性的length值。有些情况下改变可写性并不起作用（也不抛出异常）。同时，比如Array.prototype.push的一些数组操作方法也不会考虑不可读的length属性。**

**有些版本的Safari中，Object.defineProperty()  在某些情况下会忽略不同于数组当前length属性的length值。尝试改变可写性的操作会正常执行而不抛出错误，但事实上并未改变属性的可写性。**

**只在Internet Explorer 9及以后版本和Firefox 23及以后版本中，才完整地正确地支持数组length属性的重新定义。目前不要依赖于重定义数组length 属性能够起作用，或在特定情形下起作用。与此同时，即使你能够依赖于它，你也没有合适的理由这样做。**

## $\color{purple}{Internet Explorer 8 具体案例}$

**Internet Explorer 8 实现了 Object.defineProperty() 方法，但 只能在 DOM 对象上使用。 需要注意的一些事情：**

- **尝试在原生对象上使用 Object.defineProperty()会报错。**
- **属性特性必须设置一些特定的值。对于数据属性描述符，configurable, enumerable 和 writable 特性必须全部设置为 true；对于访问器属性描述符，configurable 必须设置为 true，enumerable 必须设置为 false。(?) 任何试图提供其他值(?)将导致一个错误抛出。**
- **重新配置一个属性首先需要删除该属性。如果属性没有删除，就如同重新配置前的尝试。**
