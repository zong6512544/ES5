# 静态私有变量

**$\color{green}{本章学习内容}$**

- 静态私有变量
- 私有作用域和构造函数中特权方法的区别

**$\color{green}{1.静态私有变量}$**

**在私有作用域(or模仿块级作用域)中定义私有变量或函数，同样也可以创建特权方法。**

实例如下：

```javascript
        (function () {
            //私有变量
            var abc =100;  
            //私有函数
            function run() {  
                return '私有函数'
            }
            //构造函数
            Result = function () {}
            //公有//特权⽅法
            Result.prototype.sayHI = function () {
                return run() + abc;
            }
            //使⽤了prototype导制⽅法共享了，
            //⽽abc也就变在了静态属性了
            //（所谓静态属性，就是共享于不同对象中的属性 )
        })()

        var res = new Result();
        alert(res.sayHI())
```

**解析：**

- 这个模式创建了⼀个私有作⽤域，并在其中封装了⼀个构造函数及相应的⽅法
- 在私有作⽤域中：
  - ⾸先定义了私有变量和私有函数
  - 然后⼜定义了构造函数及其公有⽅法
- 公有⽅法是在原型上定义的
  （这⼀点体现了典型的原型模式）
- 需要注意的是，这个模式在定义构造函数时并没有使⽤函数声明，⽽是使⽤了函数表达式
- 函数声明只能创建局部函数，我们需要创建全局函数
- 出于同样的原因，我们也没有在声明Result 时使⽤var 关键字

**NOTICED：**
$\color{red}{初始化未经声明的变量，总是会创建⼀个全局变量。}$
因此，Result 就成了⼀个全局变量，能够在私有作⽤域之外被访问到。

**$\color{green}{2.私有作用域和构造函数中特权方法的区别}$**

**这个模式与在构造函数中定义特权方法的主要区别：**

- 就在于私有变量和函数是由实例共享的。
- 由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。
- 而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。
